name: Deploy to VPS

on:
  pull_request:
    types: [closed]
    branches:
      - main

permissions:
  pull-requests: read
  contents: read

jobs:
  check-approval:
    runs-on: ubuntu-latest
    outputs:
      is-approved: ${{ steps.check.outputs.is-approved }}
      pr-number: ${{ github.event.pull_request.number }}
    
    steps:
      - name: Check PR approval
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const baseRef = context.payload.pull_request.base.ref;
            const headRef = context.payload.pull_request.head.ref;
            
            // Проверяем, что это PR из develop в main
            if (baseRef !== 'main' || headRef !== 'develop') {
              console.log(`Skipping: PR from ${headRef} to ${baseRef} (expected: develop -> main)`);
              core.setOutput('is-approved', 'false');
              return;
            }
            
            try {
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
              });
              
              // Проверяем, есть ли хотя бы один APPROVED review
              const hasApproval = reviews.some(review => review.state === 'APPROVED');
            
              console.log(`PR #${context.issue.number} from ${headRef} to ${baseRef}`);
              console.log(`Has approval: ${hasApproval}`);
              console.log(`Reviews: ${JSON.stringify(reviews.map(r => ({state: r.state, author: r.user.login})))}`);
              
              core.setOutput('is-approved', hasApproval.toString());
            } catch (error) {
              // Если нет доступа к reviews, считаем что approval есть (если PR merged, значит был approved через Branch Protection)
              console.log(`Cannot check reviews (may require Branch Protection): ${error.message}`);
              console.log(`PR merged status: ${context.payload.pull_request.merged}`);
              // Если PR был merged - считаем что approval был (Branch Protection не даст merge без approval)
              const hasApproval = context.payload.pull_request.merged === true;
              core.setOutput('is-approved', hasApproval.toString());
            }
    
  deploy:
    runs-on: ubuntu-latest
    needs: check-approval
    
    # Запускаем только при слиянии PR из develop в main с approval
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'develop' &&
      needs.check-approval.outputs.is-approved == 'true'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Debug PR information
      run: |
        echo "PR Base Ref: ${{ github.event.pull_request.base.ref }}"
        echo "PR Head Ref: ${{ github.event.pull_request.head.ref }}"
        echo "PR Merged: ${{ github.event.pull_request.merged }}"
        echo "PR State: ${{ github.event.pull_request.state }}"
    
    - name: Create .env file and deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        script: |
          cd /opt/appointment-system
          
          # Создаем .env файл из секретов
          cat > .env << EOF
          DB_NAME=appointment_db
          DB_USER=appointment_user
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_HOST=db
          DB_PORT=5432
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          DEBUG=False
          ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}
          PGADMIN_DEFAULT_EMAIL=admin@admin.com
          PGADMIN_PASSWORD=${{ secrets.PGADMIN_PASSWORD }}
          EOF
          
          # Обновляем код из main (так как PR уже влит)
          git fetch origin
          git checkout main
          git pull origin main
          
          # Определяем команду docker-compose (поддерживаем v1 и v2)
          if command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1; then
            # Используем docker compose v2
            docker compose down
            docker compose build --no-cache
            docker compose up -d
            sleep 10
            docker compose exec -T web python manage.py migrate
            docker compose exec -T web python manage.py collectstatic --noinput
          elif command -v docker-compose &> /dev/null; then
            # Используем docker-compose v1
            docker-compose down
            docker-compose build --no-cache
            docker-compose up -d
            sleep 10
            docker-compose exec -T web python manage.py migrate
            docker-compose exec -T web python manage.py collectstatic --noinput
          else
            # Устанавливаем docker-compose если не установлен
            echo "Installing docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose down
            docker-compose build --no-cache
            docker-compose up -d
            sleep 10
            docker-compose exec -T web python manage.py migrate
            docker-compose exec -T web python manage.py collectstatic --noinput
          fi
          
          echo "Deployment completed!"
